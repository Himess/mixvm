import { useCallback, useEffect, useRef, useState } from 'react'
import { useAccount, useWalletClient } from 'wagmi'
import { BrowserProvider, JsonRpcSigner, ethers } from 'ethers'
import { useSDKStore } from '../lib/store'
import { CONTRACTS } from '../lib/wagmi'
import { CHAIN_CONFIGS } from '../lib/chains'
import { getMerkleProof, MerkleTree, buildMerkleTreeFromEvents } from '../lib/merkle'
import { encryptNoteData, generateStealthDataForTransfer, StealthDataForContract } from '../lib/stealth'
import { secp256k1 } from '@noble/curves/secp256k1'

// Circuit paths (served from public folder)
const CIRCUIT_PATHS = {
  withdrawWasm: '/circuits/withdraw.wasm',
  withdrawZkey: '/circuits/withdraw_final.zkey',
  transferWasm: '/circuits/private_transfer.wasm',
  transferZkey: '/circuits/private_transfer_final.zkey',
}

// Get chain config dynamically based on connected chain
function getChainConfig(chainId: number | undefined) {
  if (!chainId || !CHAIN_CONFIGS[chainId]) {
    // Default to Arc Testnet
    return {
      contractAddress: CONTRACTS.arcTestnet.privateUSDC,
      usdcAddress: CHAIN_CONFIGS[5042002].usdc,
      usdcDecimals: CHAIN_CONFIGS[5042002].usdcDecimals,
      isNativeUSDC: CHAIN_CONFIGS[5042002].isNativeUSDC,
      chainId: 5042002,
    }
  }

  const config = CHAIN_CONFIGS[chainId]
  return {
    contractAddress: config.bridge,
    usdcAddress: config.usdc,
    usdcDecimals: config.usdcDecimals,
    isNativeUSDC: config.isNativeUSDC,
    chainId: chainId,
  }
}

// ERC20 ABI for USDC operations
const ERC20_ABI = [
  'function balanceOf(address owner) view returns (uint256)',
  'function allowance(address owner, address spender) view returns (uint256)',
  'function approve(address spender, uint256 amount) returns (bool)',
  'function transfer(address to, uint256 amount) returns (bool)',
  'function decimals() view returns (uint8)',
  'function symbol() view returns (string)',
  // Arc USDC wrapper specific - deposit native USDC to get ERC-20
  'function deposit() payable',
  'function withdraw(uint256 amount)',
]

// StealthRegistry addresses
// OLD registry (for reading existing registrations)
const STEALTH_REGISTRY_READ_ADDRESS = '0xd209CbDD434F646388775A8223c4644491c89fB1'
// NEW registry (for announcements - has the announce function)
const STEALTH_REGISTRY_ANNOUNCE_ADDRESS = '0x137e9693080E9beA3D6cB399EF1Ca33CE72c5477'
const STEALTH_REGISTRY_ABI = [
  'function isUserRegistered(address user) view returns (bool)',
  'function getStealthMetaAddress(address user) view returns (tuple(uint256 spendingPubKeyX, uint256 spendingPubKeyY, uint256 viewingPubKeyX, uint256 viewingPubKeyY, uint256 registeredAt))',
  // Alternative: direct mapping getter (auto-generated by Solidity)
  'function stealthAddresses(address user) view returns (uint256 spendingPubKeyX, uint256 spendingPubKeyY, uint256 viewingPubKeyX, uint256 viewingPubKeyY, uint256 registeredAt)',
  'function announce(uint256 schemeId, address stealthAddress, bytes ephemeralPubKey, uint256 viewTag, bytes metadata) external',
]

// PrivateUSDCComplete has its own stealth registry with 4 fields (no registeredAt)
const PRIVATE_USDC_STEALTH_ABI = [
  'function isRegistered(address user) view returns (bool)',
  'function stealthAddresses(address user) view returns (uint256 spendingPubKeyX, uint256 spendingPubKeyY, uint256 viewingPubKeyX, uint256 viewingPubKeyY)',
]

// ABI for contract interactions
const CONTRACT_ABI = [
  'function deposit(bytes32 commitment) external payable',
  'function depositUSDC(bytes32 commitment, uint256 amount) external',
  'function withdraw(address recipient, uint256 amount, bytes32 nullifier, bytes32 newCommitment, tuple(uint256[2] pA, uint256[2][2] pB, uint256[2] pC, uint256[5] publicSignals) proof) external',
  'function privateTransfer(bytes32 nullifier, bytes32 newSenderCommitment, bytes32 recipientCommitment, tuple(uint256 ephemeralPubKeyX, uint256 ephemeralPubKeyY, uint256 stealthAddressX, uint256 stealthAddressY, uint256 viewTag) stealthData, tuple(uint256[4] encryptedSender, uint256[4] encryptedRecipient, uint256[4] encryptedAmount) auditData, tuple(uint256[2] pA, uint256[2][2] pB, uint256[2] pC, uint256[4] publicSignals) proof) external',
  'function getMerkleRoot() view returns (bytes32)',
  'function nextLeafIndex() view returns (uint256)',
  'function isUserRegistered(address) view returns (bool)',
  'function isNullifierUsed(bytes32) view returns (bool)',
  'function isNativeUSDC() view returns (bool)',
  'function usdc() view returns (address)',
  'event Deposited(address indexed user, uint256 amount, bytes32 indexed commitment, uint256 leafIndex)',
  'event Withdrawn(bytes32 indexed nullifier, address indexed recipient, uint256 amount)',
  'event PrivateTransfer(bytes32 indexed nullifier, bytes32 indexed recipientCommitment)',
]

// Field size for BN128
const FIELD_SIZE = BigInt('21888242871839275222246405745257275088548364400416034343698204186575808495617')

// Poseidon hash instance (initialized lazily)
let poseidonInstance: ((inputs: bigint[]) => bigint) | null = null

async function initPoseidon(): Promise<(inputs: bigint[]) => bigint> {
  if (poseidonInstance) return poseidonInstance

  const { buildPoseidon } = await import('circomlibjs')
  const poseidon = await buildPoseidon()

  poseidonInstance = (inputs: bigint[]): bigint => {
    const hash = poseidon(inputs.map(x => x.toString()))
    return BigInt(poseidon.F.toString(hash))
  }

  return poseidonInstance
}

function randomFieldElement(): bigint {
  const array = new Uint8Array(31)
  crypto.getRandomValues(array)
  let hex = '0x'
  array.forEach((b) => (hex += b.toString(16).padStart(2, '0')))
  return BigInt(hex) % FIELD_SIZE
}

function toBytes32(value: bigint): string {
  return '0x' + value.toString(16).padStart(64, '0')
}

async function computeCommitment(balance: bigint, randomness: bigint): Promise<bigint> {
  const poseidon = await initPoseidon()
  return poseidon([balance, randomness])
}

async function computeNullifier(nullifierSecret: bigint, commitment: bigint): Promise<bigint> {
  const poseidon = await initPoseidon()
  return poseidon([nullifierSecret, commitment])
}

// Parse snarkjs calldata to contract format
function parseCalldata(calldata: string) {
  const parsed = JSON.parse('[' + calldata + ']')
  return {
    pA: parsed[0].map((x: string) => BigInt(x)),
    pB: parsed[1].map((row: string[]) => row.map((x: string) => BigInt(x))),
    pC: parsed[2].map((x: string) => BigInt(x)),
    publicSignals: parsed[3].map((x: string) => BigInt(x)),
  }
}

// Generate proof using Web Worker to prevent UI freeze
async function generateProofWithWorker(
  input: Record<string, unknown>,
  wasmPath: string,
  zkeyPath: string
): Promise<{ proof: unknown; publicSignals: string[]; calldata: string }> {
  return new Promise((resolve, reject) => {
    const worker = new Worker('/zkWorker.js')

    const timeout = setTimeout(() => {
      worker.terminate()
      reject(new Error('Proof generation timed out (120s)'))
    }, 120000)

    worker.onmessage = (e) => {
      clearTimeout(timeout)
      worker.terminate()

      if (e.data.success) {
        resolve({
          proof: e.data.proof,
          publicSignals: e.data.publicSignals,
          calldata: e.data.calldata
        })
      } else {
        reject(new Error(e.data.error || 'Proof generation failed'))
      }
    }

    worker.onerror = (err) => {
      clearTimeout(timeout)
      worker.terminate()
      reject(new Error(`Worker error: ${err.message}`))
    }

    worker.postMessage({
      type: 'generate',
      input,
      wasmPath,
      zkeyPath
    })
  })
}

export function usePrivateUSDC() {
  const { address, isConnected, chainId } = useAccount()
  const { data: walletClient } = useWalletClient()

  // Get dynamic chain config based on connected chain
  const chainConfig = getChainConfig(chainId)
  const CONTRACT_ADDRESS = chainConfig.contractAddress
  const USDC_ADDRESS = chainConfig.usdcAddress
  const USDC_DECIMALS = chainConfig.usdcDecimals
  const IS_NATIVE_USDC = chainConfig.isNativeUSDC

  const {
    isInitialized,
    isLoading,
    error,
    privateBalance,
    notes,
    transactions,
    setInitialized,
    setLoading,
    setError,
    setPrivateBalance,
    addNote,
    removeNote,
    addTransaction,
    updateTransaction,
  } = useSDKStore()

  const signerRef = useRef<JsonRpcSigner | null>(null)
  const providerRef = useRef<BrowserProvider | null>(null)
  const merkleTreeRef = useRef<MerkleTree | null>(null)
  const [circuitsLoaded, setCircuitsLoaded] = useState(false)

  // Get ethers signer from wallet client
  const getSigner = useCallback(async () => {
    if (!walletClient) return null

    try {
      const provider = new BrowserProvider(walletClient.transport)
      providerRef.current = provider
      const signer = await provider.getSigner()
      signerRef.current = signer
      return signer
    } catch (err) {
      console.error('Failed to get signer:', err)
      return null
    }
  }, [walletClient])

  // Initialize SDK when wallet connects
  useEffect(() => {
    if (isConnected && walletClient && !isInitialized) {
      setInitialized(true)
      // Preload circuit files
      Promise.all([
        fetch(CIRCUIT_PATHS.withdrawWasm),
        fetch(CIRCUIT_PATHS.withdrawZkey),
        fetch(CIRCUIT_PATHS.transferWasm),
        fetch(CIRCUIT_PATHS.transferZkey),
      ]).then(() => {
        setCircuitsLoaded(true)
        console.log('Circuit files loaded')
      }).catch(err => {
        console.warn('Circuit files not available:', err)
      })
    }
  }, [isConnected, walletClient, isInitialized, setInitialized])

  // Calculate balance from notes
  useEffect(() => {
    const total = notes.reduce((sum, note) => sum + BigInt(note.balance), BigInt(0))
    setPrivateBalance(total.toString())
  }, [notes, setPrivateBalance])

  // Build merkle tree from events
  const refreshMerkleTree = useCallback(async () => {
    if (!providerRef.current) return null
    try {
      const tree = await buildMerkleTreeFromEvents(CONTRACT_ADDRESS, providerRef.current)
      merkleTreeRef.current = tree
      return tree
    } catch (err) {
      console.error('Failed to build merkle tree:', err)
      return null
    }
  }, [])

  /**
   * Deposit funds into private balance
   * For Arc: Uses ERC-20 USDC wrapper (6 decimals)
   */
  const deposit = useCallback(async (amount: bigint) => {
    if (!isConnected || !walletClient) {
      throw new Error('Wallet not connected')
    }

    setLoading(true)
    setError(null)

    try {
      console.log('=== DEPOSIT START ===')
      console.log('1. Amount (raw):', amount.toString())
      console.log('2. USDC Decimals:', USDC_DECIMALS)
      console.log('3. Is Native USDC:', IS_NATIVE_USDC)
      console.log('4. USDC Address:', USDC_ADDRESS)

      const signer = await getSigner()
      if (!signer) throw new Error('Failed to get signer')
      const signerAddress = await signer.getAddress()
      console.log('5. Signer address:', signerAddress)

      // Initialize Poseidon first
      await initPoseidon()
      console.log('6. Poseidon initialized')

      // Generate commitment with real Poseidon hash
      const randomness = randomFieldElement()
      const nullifierSecret = randomFieldElement()
      console.log('7. Randomness generated:', randomness.toString().slice(0, 20) + '...')
      console.log('8. NullifierSecret generated:', nullifierSecret.toString().slice(0, 20) + '...')

      const commitment = await computeCommitment(amount, randomness)
      const commitmentBytes32 = toBytes32(commitment)
      console.log('9. Commitment computed:', commitmentBytes32)

      let tx: ethers.TransactionResponse

      if (IS_NATIVE_USDC) {
        // Native USDC: send as msg.value
        console.log('10. Using native USDC deposit...')
        const iface = new ethers.Interface(CONTRACT_ABI)
        const data = iface.encodeFunctionData('deposit', [commitmentBytes32])

        tx = await signer.sendTransaction({
          to: CONTRACT_ADDRESS,
          data,
          value: amount,
        })
      } else {
        // ERC-20 USDC: approve + depositUSDC
        console.log('10. Using ERC-20 USDC deposit...')

        // Check current allowance
        const usdcContract = new ethers.Contract(USDC_ADDRESS, ERC20_ABI, signer)
        const currentAllowance = await usdcContract.allowance(signerAddress, CONTRACT_ADDRESS)
        console.log('11. Current allowance:', currentAllowance.toString())

        // Approve if needed
        if (currentAllowance < amount) {
          console.log('12. Approving USDC spend...')
          const approveTx = await usdcContract.approve(CONTRACT_ADDRESS, amount)
          console.log('13. Approve TX:', approveTx.hash)
          await approveTx.wait()
          console.log('14. Approve confirmed')
        } else {
          console.log('12. Allowance sufficient, skipping approve')
        }

        // Call depositUSDC
        console.log('15. Calling depositUSDC...')
        const iface = new ethers.Interface(CONTRACT_ABI)
        const data = iface.encodeFunctionData('depositUSDC', [commitmentBytes32, amount])

        tx = await signer.sendTransaction({
          to: CONTRACT_ADDRESS,
          data,
        })
      }

      console.log('16. TX sent:', tx.hash)

      // Add pending transaction
      addTransaction({
        type: 'deposit',
        amount: amount.toString(),
        txHash: tx.hash,
        timestamp: Date.now(),
        status: 'pending',
      })

      // Wait for confirmation
      console.log('17. Waiting for confirmation...')
      const receipt = await tx.wait()

      if (receipt && receipt.status === 1) {
        console.log('18. TX confirmed! Block:', receipt.blockNumber)

        // Find leaf index from event
        const iface = new ethers.Interface(CONTRACT_ABI)
        let leafIndex = 0
        for (const log of receipt.logs) {
          try {
            const parsed = iface.parseLog({
              topics: log.topics as string[],
              data: log.data,
            })
            if (parsed?.name === 'Deposited') {
              leafIndex = Number(parsed.args.leafIndex)
              console.log('19. Leaf index from event:', leafIndex)
              break
            }
          } catch {
            // Skip unparseable logs
          }
        }

        // Add note to store
        const noteData = {
          commitment: commitmentBytes32,
          balance: amount.toString(),
          randomness: randomness.toString(),
          nullifierSecret: nullifierSecret.toString(),
          leafIndex,
        }
        addNote(noteData)
        console.log('20. Note stored locally:', {
          commitment: noteData.commitment,
          balance: ethers.formatUnits(noteData.balance, USDC_DECIMALS) + ' USDC',
          leafIndex: noteData.leafIndex,
        })

        // Update transaction status
        updateTransaction(tx.hash, { status: 'confirmed' })

        // Refresh merkle tree
        await refreshMerkleTree()
        console.log('21. Merkle tree refreshed')

        console.log('=== DEPOSIT COMPLETE ===')

        return {
          txHash: tx.hash,
          commitment: commitmentBytes32,
          leafIndex,
        }
      } else {
        console.error('18. TX failed! Status:', receipt?.status)
        updateTransaction(tx.hash, { status: 'failed' })
        throw new Error('Transaction failed')
      }
    } catch (err) {
      console.error('=== DEPOSIT ERROR ===', err)
      const message = err instanceof Error ? err.message : 'Deposit failed'
      setError(message)
      throw err
    } finally {
      setLoading(false)
    }
  }, [isConnected, walletClient, getSigner, setLoading, setError, addNote, addTransaction, updateTransaction, refreshMerkleTree])

  /**
   * Withdraw from private balance with ZK proof
   */
  const withdraw = useCallback(async (amount: bigint, recipient: string) => {
    if (!isConnected || !walletClient) {
      throw new Error('Wallet not connected')
    }

    // Find a note with sufficient balance
    const note = notes.find((n) => BigInt(n.balance) >= amount)
    if (!note) {
      throw new Error('Insufficient balance')
    }

    setLoading(true)
    setError(null)

    try {
      console.log('=== WITHDRAW START ===')
      console.log('1. Amount to withdraw:', amount.toString())
      console.log('2. Recipient:', recipient)
      console.log('3. Note balance:', note.balance)
      console.log('4. Note leaf index:', note.leafIndex)

      const signer = await getSigner()
      if (!signer) throw new Error('Failed to get signer')
      console.log('5. Signer obtained')

      // Import snarkjs dynamically
      const snarkjs = await import('snarkjs')
      console.log('6. snarkjs loaded')

      // Initialize Poseidon
      await initPoseidon()
      console.log('7. Poseidon initialized')

      // Build merkle tree from contract events (must match contract's merkle root)
      console.log('8. Building merkle tree from contract events...')
      const { buildMerkleTreeFromEvents, initPoseidon: initMerklePoseidon } = await import('../lib/merkle')
      await initMerklePoseidon()

      if (!providerRef.current) throw new Error('Provider not available')
      const contractTree = await buildMerkleTreeFromEvents(CONTRACT_ADDRESS, providerRef.current)
      console.log('9. Merkle tree built')

      // Get the contract's current merkle root for comparison
      const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, providerRef.current)
      const contractMerkleRoot = await contract.getMerkleRoot()
      const localTreeRoot = contractTree.getRoot()
      console.log('10. Contract merkle root:', contractMerkleRoot)
      console.log('11. Local tree root:', '0x' + localTreeRoot.toString(16).padStart(64, '0'))

      // Get merkle proof from the tree
      const merkleProof = contractTree.getProof(note.leafIndex)
      console.log('12. Merkle proof obtained')

      // Calculate old commitment (must match what's in the tree)
      const oldCommitment = await computeCommitment(BigInt(note.balance), BigInt(note.randomness))
      const oldCommitmentHex = '0x' + oldCommitment.toString(16).padStart(64, '0')
      console.log('13. Computed old commitment:', oldCommitmentHex)
      console.log('14. Stored commitment:', note.commitment)
      console.log('15. Commitments match:', oldCommitmentHex.toLowerCase() === note.commitment.toLowerCase())

      // Calculate nullifier using the computed old commitment
      const nullifier = await computeNullifier(BigInt(note.nullifierSecret), oldCommitment)
      console.log('16. Nullifier computed:', '0x' + nullifier.toString(16).padStart(64, '0'))

      // Calculate new commitment for remaining balance
      const currentBalance = BigInt(note.balance)
      const newBalance = currentBalance - amount
      const newRandomness = randomFieldElement()
      const newCommitment = newBalance > 0n
        ? await computeCommitment(newBalance, newRandomness)
        : BigInt(0)
      console.log('17. New balance:', newBalance.toString())
      console.log('18. New commitment:', newCommitment === 0n ? '0' : '0x' + newCommitment.toString(16).padStart(64, '0'))

      // Convert recipient address to BigInt (remove 0x prefix)
      const recipientBigInt = BigInt(recipient)
      console.log('19. Recipient as BigInt:', recipientBigInt.toString())

      // Prepare circuit input
      const input = {
        // Public inputs
        merkleRoot: merkleProof.root.toString(),
        nullifier: nullifier.toString(),
        withdrawAmount: amount.toString(),
        newCommitment: newCommitment.toString(),
        recipientAddress: recipientBigInt.toString(),
        // Private inputs
        balance: note.balance,
        randomness: note.randomness,
        nullifierSecret: note.nullifierSecret,
        newRandomness: newRandomness.toString(),
        merklePathElements: merkleProof.pathElements.map(e => e.toString()),
        merklePathIndices: merkleProof.pathIndices.map(i => i.toString()),
      }

      console.log('20. Circuit input prepared')
      console.log('    - merkleRoot:', input.merkleRoot)
      console.log('    - nullifier:', input.nullifier)
      console.log('    - withdrawAmount:', input.withdrawAmount)

      console.log('21. Generating withdraw proof...')

      // Generate ZK proof
      const { proof, publicSignals } = await snarkjs.groth16.fullProve(
        input,
        CIRCUIT_PATHS.withdrawWasm,
        CIRCUIT_PATHS.withdrawZkey
      )

      console.log('22. Proof generated')
      console.log('23. Public signals:', publicSignals)

      // Verify proof off-chain before submitting
      try {
        const vkeyResponse = await fetch('/circuits/withdraw_vkey.json')
        if (vkeyResponse.ok) {
          const vkey = await vkeyResponse.json()
          const isValid = await snarkjs.groth16.verify(vkey, publicSignals, proof)
          console.log('24. Off-chain proof verification:', isValid ? '✅ VALID' : '❌ INVALID')
          if (!isValid) {
            throw new Error('Withdraw proof verification failed off-chain!')
          }
        } else {
          console.log('24. Verification key not found, skipping off-chain verification')
        }
      } catch (verifyErr) {
        console.warn('Off-chain verification skipped:', verifyErr)
      }

      // Convert to contract format
      const calldata = await snarkjs.groth16.exportSolidityCallData(proof, publicSignals)
      const proofData = parseCalldata(calldata)

      console.log('25. Submitting transaction...')

      // Create transaction - convert all BigInt to string for ethers.js
      // Contract signature: withdraw(address recipient, uint256 amount, bytes32 nullifier, bytes32 newCommitment, WithdrawProofData proof)
      const iface = new ethers.Interface(CONTRACT_ABI)
      const data = iface.encodeFunctionData('withdraw', [
        recipient,  // address recipient
        amount,     // uint256 amount
        toBytes32(nullifier),      // bytes32 nullifier
        toBytes32(newCommitment),  // bytes32 newCommitment
        {
          pA: proofData.pA.map((x: bigint) => x.toString()),
          pB: proofData.pB.map((row: bigint[]) => row.map((x: bigint) => x.toString())),
          pC: proofData.pC.map((x: bigint) => x.toString()),
          publicSignals: proofData.publicSignals.map((x: bigint) => x.toString()),
        },
      ])

      const tx = await signer.sendTransaction({
        to: CONTRACT_ADDRESS,
        data,
        gasLimit: 3000000, // Increased gas limit
      })

      console.log('26. TX sent:', tx.hash)

      // Add pending transaction
      addTransaction({
        type: 'withdraw',
        amount: amount.toString(),
        txHash: tx.hash,
        timestamp: Date.now(),
        status: 'pending',
        recipient,
      })

      // Wait for confirmation
      const receipt = await tx.wait()

      if (receipt && receipt.status === 1) {
        console.log('27. TX confirmed!')

        // Remove old note
        removeNote(note.commitment)

        // Add new note if there's remaining balance
        if (newBalance > 0n) {
          // Get the new leaf index from events if possible
          let newLeafIndex = note.leafIndex + 1
          for (const log of receipt.logs) {
            try {
              const parsed = iface.parseLog({
                topics: log.topics as string[],
                data: log.data,
              })
              if (parsed?.name === 'Deposited') {
                newLeafIndex = Number(parsed.args.leafIndex)
                break
              }
            } catch {
              // Skip
            }
          }

          addNote({
            commitment: toBytes32(newCommitment),
            balance: newBalance.toString(),
            randomness: newRandomness.toString(),
            nullifierSecret: note.nullifierSecret,
            leafIndex: newLeafIndex,
          })
        }

        updateTransaction(tx.hash, { status: 'confirmed' })

        console.log('=== WITHDRAW COMPLETE ===')

        return {
          txHash: tx.hash,
          nullifier: toBytes32(nullifier),
          newCommitment: toBytes32(newCommitment),
        }
      } else {
        console.error('27. TX failed!')
        updateTransaction(tx.hash, { status: 'failed' })
        throw new Error('Withdraw transaction failed')
      }
    } catch (err) {
      console.error('=== WITHDRAW ERROR ===', err)
      const message = err instanceof Error ? err.message : 'Withdraw failed'
      setError(message)
      throw err
    } finally {
      setLoading(false)
    }
  }, [isConnected, walletClient, notes, getSigner, setLoading, setError, addNote, removeNote, addTransaction, updateTransaction])

  /**
   * Private transfer to another user with ZK proof
   */
  const transfer = useCallback(async (
    recipientAddress: string,
    amount: bigint
  ) => {
    if (!isConnected || !walletClient) {
      throw new Error('Wallet not connected')
    }

    // Find a note with sufficient balance
    const note = notes.find((n) => BigInt(n.balance) >= amount)
    if (!note) {
      throw new Error('Insufficient balance')
    }

    setLoading(true)
    setError(null)

    try {
      console.log('1. Getting signer...')
      const signer = await getSigner()
      if (!signer) throw new Error('Failed to get signer')
      console.log('2. Signer obtained')

      // Build merkle tree from contract events (must match contract's merkle root)
      console.log('3. Building merkle tree from contract events...')

      // Initialize Poseidon for merkle tree
      const { buildMerkleTreeFromEvents, initPoseidon: initMerklePoseidon } = await import('../lib/merkle')
      await initMerklePoseidon()
      console.log('3.5. Merkle Poseidon initialized')

      // Build tree from contract events to match contract's merkle root
      if (!providerRef.current) throw new Error('Provider not available')
      const contractTree = await buildMerkleTreeFromEvents(CONTRACT_ADDRESS, providerRef.current)
      console.log('3.6. Contract tree built')

      // Get the contract's current merkle root for comparison
      const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, providerRef.current)
      const contractMerkleRoot = await contract.getMerkleRoot()
      const localTreeRoot = contractTree.getRoot()
      console.log('3.7. Contract merkle root:', contractMerkleRoot)
      console.log('3.8. Local tree root:', '0x' + localTreeRoot.toString(16).padStart(64, '0'))

      // Get the next leaf index BEFORE the transfer (new commitments will be added here)
      const nextLeafIndexBeforeTransfer = Number(await contract.nextLeafIndex())
      console.log('3.9. Next leaf index before transfer:', nextLeafIndexBeforeTransfer)

      // Use the leaf index from the note (set during deposit)
      const leafIndex = note.leafIndex
      console.log('4. Using leaf index from note:', leafIndex)

      const merkleProof = contractTree.getProof(leafIndex)
      console.log('5. Merkle proof obtained from contract tree')

      // Initialize Poseidon first
      console.log('6. Initializing Poseidon hash...')
      await initPoseidon()
      console.log('7. Poseidon initialized')

      // Calculate commitments
      const currentBalance = BigInt(note.balance)
      const newSenderBalance = currentBalance - amount
      const newSenderRandomness = randomFieldElement()
      const newSenderCommitment = newSenderBalance > 0n
        ? await computeCommitment(newSenderBalance, newSenderRandomness)
        : BigInt(0)

      const recipientRandomness = randomFieldElement()
      const recipientNullifierSecret = randomFieldElement() // Generate for recipient
      const recipientCommitment = await computeCommitment(amount, recipientRandomness)

      // Calculate nullifier - need to compute old commitment first with Poseidon
      const oldCommitment = await computeCommitment(BigInt(note.balance), BigInt(note.randomness))
      const nullifier = await computeNullifier(BigInt(note.nullifierSecret), oldCommitment)

      // Debug: Compare old commitment with stored commitment
      const oldCommitmentHex = '0x' + oldCommitment.toString(16).padStart(64, '0')
      console.log('8. Stored commitment:', note.commitment)
      console.log('8. Computed oldCommitment:', oldCommitmentHex)
      console.log('8. Commitments match:', note.commitment.toLowerCase() === oldCommitmentHex.toLowerCase())

      // Prepare circuit input
      const input = {
        // Public inputs
        merkleRoot: merkleProof.root.toString(),
        nullifier: nullifier.toString(),
        newSenderCommitment: newSenderCommitment.toString(),
        recipientCommitment: recipientCommitment.toString(),
        // Private inputs
        senderBalance: note.balance,
        senderRandomness: note.randomness,
        senderNullifierSecret: note.nullifierSecret,
        transferAmount: amount.toString(),
        newSenderRandomness: newSenderRandomness.toString(),
        recipientRandomness: recipientRandomness.toString(),
        merklePathElements: merkleProof.pathElements.map(e => e.toString()),
        merklePathIndices: merkleProof.pathIndices.map(i => i.toString()),
      }

      console.log('Generating transfer proof...')

      // Generate ZK proof directly (may freeze UI briefly)
      const snarkjs = await import('snarkjs')

      console.log('snarkjs loaded, starting proof generation...')

      const { proof, publicSignals } = await snarkjs.groth16.fullProve(
        input,
        CIRCUIT_PATHS.transferWasm,
        CIRCUIT_PATHS.transferZkey
      )

      console.log('Proof generated, exporting calldata...')
      console.log('Public signals from proof:', publicSignals)

      // Convert to contract format
      const calldata = await snarkjs.groth16.exportSolidityCallData(proof, publicSignals)
      console.log('Raw calldata from snarkjs:', calldata)
      const proofData = parseCalldata(calldata)
      console.log('Parsed proofData:', {
        pA: proofData.pA.map((x: bigint) => x.toString()),
        pB: proofData.pB.map((row: bigint[]) => row.map((x: bigint) => x.toString())),
        pC: proofData.pC.map((x: bigint) => x.toString()),
        publicSignals: proofData.publicSignals.map((x: bigint) => x.toString()),
      })

      // Debug: Compare proof's merkle root with contract's merkle root
      const proofMerkleRoot = '0x' + BigInt(publicSignals[0]).toString(16).padStart(64, '0')
      console.log('Proof merkle root:', proofMerkleRoot)
      console.log('Contract merkle root:', contractMerkleRoot)
      console.log('Roots match:', proofMerkleRoot.toLowerCase() === contractMerkleRoot.toLowerCase())

      // Verify proof off-chain before submitting
      try {
        const vkeyResponse = await fetch('/circuits/private_transfer_vkey.json')
        if (vkeyResponse.ok) {
          const vkey = await vkeyResponse.json()
          const isValid = await snarkjs.groth16.verify(vkey, publicSignals, proof)
          console.log('Off-chain proof verification:', isValid ? '✅ VALID' : '❌ INVALID')
          if (!isValid) {
            throw new Error('Proof verification failed off-chain!')
          }
        }
      } catch (verifyErr) {
        console.error('Off-chain verification error:', verifyErr)
      }

      console.log('Proof verified, submitting transaction...')

      // Get recipient's stealth meta-address for proper stealth address generation
      console.log('Fetching recipient stealth keys...')
      let recipientSpendingPubKey: Uint8Array | null = null
      let recipientViewingPubKey: Uint8Array | null = null
      let stealthDataForContract: StealthDataForContract | null = null

      // Try StealthRegistry first - use JsonRpcProvider to avoid MetaMask issues
      try {
        // Use dedicated provider for read calls (more reliable than MetaMask)
        const readProvider = new ethers.JsonRpcProvider('https://arc-testnet.drpc.org', 5042002)
        const stealthRegistry = new ethers.Contract(STEALTH_REGISTRY_READ_ADDRESS, STEALTH_REGISTRY_ABI, readProvider)

        const isRegistered = await stealthRegistry.isUserRegistered(recipientAddress)
        console.log('Recipient registered in StealthRegistry:', isRegistered)

        if (isRegistered) {
          let spendingPubKeyX: bigint, spendingPubKeyY: bigint, viewingPubKeyX: bigint, viewingPubKeyY: bigint

          // Use raw call to avoid ABI decoding issues
          try {
            console.log('Calling getStealthMetaAddress for:', recipientAddress)

            // Use ethers to encode the function call
            const iface = new ethers.Interface(['function getStealthMetaAddress(address user)'])
            const callData = iface.encodeFunctionData('getStealthMetaAddress', [recipientAddress])
            console.log('Encoded call data:', callData)

            // Make raw call
            const rawResult = await readProvider.call({
              to: STEALTH_REGISTRY_READ_ADDRESS,
              data: callData,
            })

            console.log('Raw result from getStealthMetaAddress:', rawResult)
            console.log('Raw result length:', rawResult?.length)

            // Contract returns 4 uint256 values (128 bytes = 256 hex chars + 0x = 258)
            // Or 5 uint256 values if registeredAt is included (160 bytes = 320 hex chars + 0x = 322)
            if (rawResult && rawResult.length >= 258) { // 0x + 4*64 hex chars minimum
              // Manually decode uint256 values
              const hex = rawResult.slice(2) // Remove 0x
              spendingPubKeyX = BigInt('0x' + hex.slice(0, 64))
              spendingPubKeyY = BigInt('0x' + hex.slice(64, 128))
              viewingPubKeyX = BigInt('0x' + hex.slice(128, 192))
              viewingPubKeyY = BigInt('0x' + hex.slice(192, 256))

              console.log('Manually decoded stealth keys:')
              console.log('  spendingPubKeyX:', spendingPubKeyX.toString().slice(0, 20) + '...')
              console.log('  spendingPubKeyY:', spendingPubKeyY.toString().slice(0, 20) + '...')
              console.log('  viewingPubKeyX:', viewingPubKeyX.toString().slice(0, 20) + '...')
              console.log('  viewingPubKeyY:', viewingPubKeyY.toString().slice(0, 20) + '...')
            } else {
              throw new Error('Invalid response length: ' + (rawResult?.length || 0))
            }
          } catch (metaErr) {
            console.log('getStealthMetaAddress failed:', metaErr)
            throw metaErr
          }

          console.log('Spending key X:', spendingPubKeyX.toString().slice(0, 20) + '...')
          console.log('Viewing key X:', viewingPubKeyX.toString().slice(0, 20) + '...')

          // Check if keys are valid (not zero)
          if (spendingPubKeyX === 0n || viewingPubKeyX === 0n) {
            console.warn('Warning: Stealth keys are zero - user may not be properly registered')
          } else {
            // Reconstruct public keys from coordinates
            recipientSpendingPubKey = secp256k1.ProjectivePoint.fromAffine({
              x: spendingPubKeyX,
              y: spendingPubKeyY,
            }).toRawBytes(false)

            recipientViewingPubKey = secp256k1.ProjectivePoint.fromAffine({
              x: viewingPubKeyX,
              y: viewingPubKeyY,
            }).toRawBytes(false)

            console.log('Got stealth keys from StealthRegistry')
          }
        }
      } catch (e) {
        console.error('StealthRegistry check failed completely:', e)
        console.log('Trying PrivateUSDC internal registry...')
      }

      // Fallback to PrivateUSDC internal registry
      if (!recipientSpendingPubKey) {
        try {
          const privateUsdc = new ethers.Contract(CONTRACT_ADDRESS, PRIVATE_USDC_STEALTH_ABI, signer)
          const isRegistered = await privateUsdc.isRegistered(recipientAddress)
          console.log('Recipient registered in PrivateUSDC:', isRegistered)

          if (isRegistered) {
            const meta = await privateUsdc.stealthAddresses(recipientAddress)
            const spendingPubKeyX = BigInt(meta.spendingPubKeyX)
            const spendingPubKeyY = BigInt(meta.spendingPubKeyY)
            const viewingPubKeyX = BigInt(meta.viewingPubKeyX)
            const viewingPubKeyY = BigInt(meta.viewingPubKeyY)

            recipientSpendingPubKey = secp256k1.ProjectivePoint.fromAffine({
              x: spendingPubKeyX,
              y: spendingPubKeyY,
            }).toRawBytes(false)

            recipientViewingPubKey = secp256k1.ProjectivePoint.fromAffine({
              x: viewingPubKeyX,
              y: viewingPubKeyY,
            }).toRawBytes(false)

            console.log('Got stealth keys from PrivateUSDC internal registry')
          }
        } catch (e) {
          console.log('PrivateUSDC internal registry check failed:', e)
        }
      }

      // Generate proper stealth data if recipient is registered
      let stealthData
      if (recipientSpendingPubKey && recipientViewingPubKey) {
        console.log('Generating stealth address for recipient...')
        stealthDataForContract = generateStealthDataForTransfer(
          recipientSpendingPubKey,
          recipientViewingPubKey
        )
        console.log('Stealth address generated:', stealthDataForContract.stealthAddress)

        stealthData = {
          ephemeralPubKeyX: stealthDataForContract.ephemeralPubKeyX.toString(),
          ephemeralPubKeyY: stealthDataForContract.ephemeralPubKeyY.toString(),
          stealthAddressX: stealthDataForContract.stealthPubKeyX.toString(),
          stealthAddressY: stealthDataForContract.stealthPubKeyY.toString(),
          viewTag: stealthDataForContract.viewTag.toString(),
        }
      } else {
        // Fallback: use dummy values (privacy not protected for unregistered recipients)
        console.warn('Recipient not registered - using dummy stealth data (privacy reduced!)')
        stealthData = {
          ephemeralPubKeyX: randomFieldElement().toString(),
          ephemeralPubKeyY: randomFieldElement().toString(),
          stealthAddressX: randomFieldElement().toString(), // Don't expose real address
          stealthAddressY: randomFieldElement().toString(),
          viewTag: (randomFieldElement() % BigInt(2**64)).toString(),
        }
      }

      // Audit data (placeholder)
      const auditData = {
        encryptedSender: ['0', '0', '0', '0'],
        encryptedRecipient: ['0', '0', '0', '0'],
        encryptedAmount: [amount.toString(), '0', '0', '0'],
      }

      // Create transaction - convert all BigInt to string for ethers.js
      const iface = new ethers.Interface(CONTRACT_ABI)
      const data = iface.encodeFunctionData('privateTransfer', [
        toBytes32(nullifier),
        toBytes32(newSenderCommitment),
        toBytes32(recipientCommitment),
        stealthData,
        auditData,
        {
          pA: proofData.pA.map((x: bigint) => x.toString()),
          pB: proofData.pB.map((row: bigint[]) => row.map((x: bigint) => x.toString())),
          pC: proofData.pC.map((x: bigint) => x.toString()),
          publicSignals: proofData.publicSignals.map((x: bigint) => x.toString()),
        },
      ])

      console.log('Transaction data length:', data.length)
      console.log('Transaction data preview:', data.slice(0, 200) + '...')

      const tx = await signer.sendTransaction({
        to: CONTRACT_ADDRESS,
        data,
        gasLimit: 3000000,
      })

      // Add pending transaction
      addTransaction({
        type: 'transfer',
        amount: amount.toString(),
        txHash: tx.hash,
        timestamp: Date.now(),
        status: 'pending',
        recipient: recipientAddress,
      })

      // Wait for confirmation - handle transaction replacement (repricing)
      let receipt
      try {
        receipt = await tx.wait()
      } catch (waitError: unknown) {
        // Check if transaction was replaced but still succeeded
        const err = waitError as { code?: string; receipt?: { status: number; hash: string } }
        if (err.code === 'TRANSACTION_REPLACED' && err.receipt?.status === 1) {
          console.log('Transaction was repriced but succeeded:', err.receipt.hash)
          receipt = err.receipt
        } else {
          throw waitError
        }
      }

      if (receipt && receipt.status === 1) {
        console.log('Transfer confirmed! Processing post-transfer actions...')
        // Remove old note
        removeNote(note.commitment)

        // New commitments are added at nextLeafIndexBeforeTransfer:
        // - Sender's new commitment (if newSenderBalance > 0) at nextLeafIndexBeforeTransfer
        // - Recipient's commitment at nextLeafIndexBeforeTransfer + (newSenderBalance > 0 ? 1 : 0)
        const senderNewLeafIndex = nextLeafIndexBeforeTransfer
        const recipientLeafIndex = newSenderBalance > 0n
          ? nextLeafIndexBeforeTransfer + 1
          : nextLeafIndexBeforeTransfer

        console.log('New sender leaf index:', senderNewLeafIndex)
        console.log('Recipient leaf index:', recipientLeafIndex)

        // Add new note for remaining balance
        if (newSenderBalance > 0n) {
          addNote({
            commitment: toBytes32(newSenderCommitment),
            balance: newSenderBalance.toString(),
            randomness: newSenderRandomness.toString(),
            nullifierSecret: note.nullifierSecret,
            leafIndex: senderNewLeafIndex,
          })
        }

        updateTransaction(tx.hash, { status: 'confirmed' })

        // Prepare recipient note data
        const recipientNoteData = {
          commitment: toBytes32(recipientCommitment),
          balance: amount.toString(),
          randomness: recipientRandomness.toString(),
          nullifierSecret: recipientNullifierSecret.toString(),
          leafIndex: recipientLeafIndex,
        }

        // Try to encrypt and announce the note data for the recipient
        let encryptedAnnounced = false
        if (recipientViewingPubKey && stealthDataForContract) {
          try {
            // Encrypt the note data with recipient's viewing public key
            console.log('Encrypting note data for recipient...')
            const encryptedNoteHex = await encryptNoteData(recipientViewingPubKey, recipientNoteData)
            console.log('Note data encrypted, length:', encryptedNoteHex.length)

            // Use the ephemeral public key from stealth data generation
            const ephemeralPubKeyHex = ethers.hexlify(stealthDataForContract.ephemeralPubKey)

            // Debug all parameters
            console.log('Announce parameters:')
            console.log('  schemeId:', 1)
            console.log('  stealthAddress:', stealthDataForContract.stealthAddress)
            console.log('  ephemeralPubKey:', ephemeralPubKeyHex.slice(0, 20) + '...')
            console.log('  ephemeralPubKey length:', ephemeralPubKeyHex.length, '(expected: 132 for 65 bytes)')
            console.log('  ephemeralPubKey valid hex:', /^0x[0-9a-fA-F]+$/.test(ephemeralPubKeyHex))
            console.log('  viewTag:', stealthDataForContract.viewTag, '(type:', typeof stealthDataForContract.viewTag, ')')
            console.log('  metadata:', encryptedNoteHex.slice(0, 20) + '...')
            console.log('  metadata length:', encryptedNoteHex.length)
            console.log('  metadata valid hex:', /^0x[0-9a-fA-F]+$/.test(encryptedNoteHex))

            // Announce to NEW StealthRegistry (which has the announce function)
            console.log('Announcing to StealthRegistry with stealth address...')
            console.log('StealthRegistry ANNOUNCE address:', STEALTH_REGISTRY_ANNOUNCE_ADDRESS)

            // Verify we're on the right network
            const signerNetwork = await signer.provider?.getNetwork()
            console.log('Signer network:', signerNetwork?.chainId?.toString())

            const stealthRegistry = new ethers.Contract(STEALTH_REGISTRY_ANNOUNCE_ADDRESS, STEALTH_REGISTRY_ABI, signer)

            // Test: verify contract is accessible by reading announcement count
            try {
              const directProvider = new ethers.JsonRpcProvider('https://arc-testnet.drpc.org', 5042002)
              const readRegistry = new ethers.Contract(
                STEALTH_REGISTRY_ANNOUNCE_ADDRESS,
                ['function getAnnouncementCount() view returns (uint256)'],
                directProvider
              )
              const count = await readRegistry.getAnnouncementCount()
              console.log('StealthRegistry accessible, current announcement count:', count.toString())

              // Verify the contract has the announce function by checking bytecode contains the selector
              const bytecode = await directProvider.getCode(STEALTH_REGISTRY_ANNOUNCE_ADDRESS)
              const announceSelector = '2cd46d6c' // First 4 bytes of keccak256("announce(uint256,address,bytes,uint256,bytes)")
              const hasAnnounce = bytecode.toLowerCase().includes(announceSelector)
              console.log('Contract has announce function (selector 0x2cd46d6c):', hasAnnounce)
            } catch (readErr) {
              console.error('Could not read from StealthRegistry:', readErr)
            }

            // Try direct contract call first (simpler approach)
            console.log('Attempting announce via contract method...')
            try {
              // Use direct provider for simulation first
              const directProvider = new ethers.JsonRpcProvider('https://arc-testnet.drpc.org', 5042002)
              const testRegistry = new ethers.Contract(STEALTH_REGISTRY_ANNOUNCE_ADDRESS, STEALTH_REGISTRY_ABI, directProvider)

              // Simulate the call
              await testRegistry.announce.staticCall(
                1,
                stealthDataForContract.stealthAddress,
                ephemeralPubKeyHex,
                stealthDataForContract.viewTag,
                encryptedNoteHex
              )
              console.log('Static call simulation succeeded!')
            } catch (simErr: unknown) {
              const se = simErr as { message?: string; reason?: string }
              console.warn('Static call simulation failed:', se.reason || se.message?.slice(0, 200))
            }

            // Manually encode to debug
            const announceData = stealthRegistry.interface.encodeFunctionData('announce', [
              1, // schemeId
              stealthDataForContract.stealthAddress,
              ephemeralPubKeyHex,
              stealthDataForContract.viewTag, // Keep as number, ethers will handle conversion
              encryptedNoteHex,
            ])
            console.log('Encoded announce data length:', announceData.length)
            console.log('Encoded announce data preview:', announceData.slice(0, 100) + '...')

            // Try to estimate gas using direct RPC (more reliable than MetaMask)
            let gasLimit = 800000n // Default high gas limit
            try {
              const directProvider = new ethers.JsonRpcProvider('https://arc-testnet.drpc.org', 5042002)
              const estimatedGas = await directProvider.estimateGas({
                from: await signer.getAddress(),
                to: STEALTH_REGISTRY_ANNOUNCE_ADDRESS,
                data: announceData,
              })
              console.log('Estimated gas for announce (direct RPC):', estimatedGas.toString())
              gasLimit = (estimatedGas * 120n) / 100n
            } catch (estimateErr: unknown) {
              const err = estimateErr as { message?: string; reason?: string; data?: string }
              console.warn('Gas estimation failed, using default gas limit:', gasLimit.toString())
              console.warn('  Error:', err.message?.slice(0, 200))

              // Try to simulate the call to get more details
              try {
                const directProvider = new ethers.JsonRpcProvider('https://arc-testnet.drpc.org', 5042002)
                await directProvider.call({
                  from: await signer.getAddress(),
                  to: STEALTH_REGISTRY_ANNOUNCE_ADDRESS,
                  data: announceData,
                })
                console.log('eth_call succeeded - transaction should work')
              } catch (callErr: unknown) {
                const ce = callErr as { message?: string; data?: string }
                console.error('eth_call also failed:', ce.message?.slice(0, 300))
                console.error('Call error data:', ce.data)
              }
            }
            console.log('Using gas limit:', gasLimit.toString())

            console.log('Sending announce transaction with gas limit:', gasLimit.toString())
            const announceTx = await signer.sendTransaction({
              to: STEALTH_REGISTRY_ANNOUNCE_ADDRESS,
              data: announceData,
              gasLimit,
            })

            console.log('Announce TX sent:', announceTx.hash)
            console.log('Stealth address used:', stealthDataForContract.stealthAddress)

            // Wait with a timeout
            const announceReceipt = await Promise.race([
              announceTx.wait(),
              new Promise((_, reject) =>
                setTimeout(() => reject(new Error('Announce TX timeout after 60s')), 60000)
              ),
            ]) as ethers.TransactionReceipt | null

            console.log('Announce TX receipt:', announceReceipt ? 'received' : 'null')
            console.log('Announce TX status:', announceReceipt?.status)

            if (announceReceipt?.status === 1) {
              console.log('Announce TX confirmed! Recipient can auto-scan for this note.')
              encryptedAnnounced = true
            } else {
              console.error('Announce TX failed with status:', announceReceipt?.status)
              // Log gas used to see if it ran out
              if (announceReceipt) {
                console.error('Gas used:', announceReceipt.gasUsed?.toString())
              }
            }
          } catch (announceErr: unknown) {
            const err = announceErr as { message?: string; reason?: string; code?: string; data?: string; receipt?: { status: number } }
            console.error('Failed to announce encrypted note:')
            console.error('  Message:', err.message?.slice(0, 300))
            console.error('  Reason:', err.reason)
            console.error('  Code:', err.code)

            // Check if transaction was actually sent but wait failed
            if (err.code === 'TRANSACTION_REPLACED' && err.receipt?.status === 1) {
              console.log('Announce transaction was replaced but succeeded!')
              encryptedAnnounced = true
            } else {
              console.warn('Recipient can still use manual import')
            }
          }
        } else {
          console.log('Recipient not registered - manual note sharing required')
        }

        // Return recipient note data for sharing (fallback if announce failed)
        return {
          txHash: tx.hash,
          nullifier: toBytes32(nullifier),
          newSenderCommitment: toBytes32(newSenderCommitment),
          recipientCommitment: toBytes32(recipientCommitment),
          encryptedAnnounced, // true if auto-scan will work
          // Data recipient needs to withdraw (SHARE THIS WITH RECIPIENT if encryptedAnnounced is false!)
          recipientNoteData,
        }
      } else {
        updateTransaction(tx.hash, { status: 'failed' })
        throw new Error('Transfer transaction failed')
      }
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Transfer failed'
      setError(message)
      throw err
    } finally {
      setLoading(false)
    }
  }, [isConnected, walletClient, notes, getSigner, setLoading, setError, addNote, removeNote, addTransaction, updateTransaction, refreshMerkleTree])

  /**
   * Get ERC-20 USDC balance for the connected wallet
   */
  const getUSDCBalance = useCallback(async (): Promise<bigint> => {
    if (!providerRef.current || !address || !USDC_ADDRESS) return 0n
    try {
      const usdcContract = new ethers.Contract(USDC_ADDRESS, ERC20_ABI, providerRef.current)
      const balance = await usdcContract.balanceOf(address)
      return BigInt(balance.toString())
    } catch (err) {
      console.error('Failed to get USDC balance:', err)
      return 0n
    }
  }, [address, USDC_ADDRESS])

  /**
   * Wrap native USDC to ERC-20 USDC (Arc specific)
   */
  const wrapUSDC = useCallback(async (amount: bigint) => {
    if (!isConnected || !walletClient) {
      throw new Error('Wallet not connected')
    }

    setLoading(true)
    setError(null)

    try {
      console.log('=== WRAP USDC START ===')
      console.log('Amount to wrap:', ethers.formatEther(amount), 'native USDC')

      const signer = await getSigner()
      if (!signer) throw new Error('Failed to get signer')

      // Call deposit() on the USDC wrapper contract with native value
      const usdcContract = new ethers.Contract(USDC_ADDRESS, ERC20_ABI, signer)
      const tx = await usdcContract.deposit({ value: amount })
      console.log('Wrap TX sent:', tx.hash)

      await tx.wait()
      console.log('Wrap TX confirmed!')
      console.log('=== WRAP USDC COMPLETE ===')

      return tx.hash
    } catch (err) {
      console.error('=== WRAP USDC ERROR ===', err)
      const message = err instanceof Error ? err.message : 'Wrap failed'
      setError(message)
      throw err
    } finally {
      setLoading(false)
    }
  }, [isConnected, walletClient, getSigner, setLoading, setError])

  /**
   * Format balance for display (uses correct decimals)
   */
  const formatBalance = useCallback((wei: string | bigint) => {
    const value = typeof wei === 'string' ? BigInt(wei) : wei
    const formatted = Number(value) / Math.pow(10, USDC_DECIMALS)
    return formatted.toLocaleString('en-US', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 6,
    })
  }, [USDC_DECIMALS])

  return {
    // State
    isConnected,
    isInitialized,
    isLoading,
    error,
    address,
    chainId,
    circuitsLoaded,

    // Balance
    privateBalance,
    formattedBalance: formatBalance(privateBalance),
    notes,

    // Transactions
    transactions,

    // Actions
    deposit,
    withdraw,
    transfer,
    wrapUSDC,

    // Utilities
    formatBalance,
    getUSDCBalance,
    contractAddress: CONTRACT_ADDRESS,
    usdcAddress: USDC_ADDRESS,
    usdcDecimals: USDC_DECIMALS,
    isNativeUSDC: IS_NATIVE_USDC,
    refreshMerkleTree,
  }
}
